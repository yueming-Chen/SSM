var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Directive, Input, ElementRef, TemplateRef, ViewContainerRef, Renderer, ComponentFactoryResolver, Injector, Output, EventEmitter, NgZone, HostListener } from '@angular/core';
import * as Tether from 'tether';
import 'rxjs/add/operator/take';
import { TooltipComponent } from './tooltip.component';
import { placement } from './placements';
import { bind } from "@ay/util/dist";
var TooltipDirective = (function () {
    function TooltipDirective(element, viewContainer, injector, ngZone, renderer, componentFactoryResolver) {
        this.element = element;
        this.viewContainer = viewContainer;
        this.injector = injector;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.behavior = "hover";
        this.toggled = new EventEmitter();
        this._direction = 'top';
        this.openDelay = 0;
        this.closeDelay = 0;
        this.toggleTimeout = null;
        this.interactiveSubscription = null;
        this.popoverFactory = componentFactoryResolver.resolveComponentFactory(TooltipComponent);
    }
    Object.defineProperty(TooltipDirective.prototype, "direction", {
        set: function (_direction) {
            this._direction = _direction || 'top';
            this.setTether();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "delay", {
        set: function (delay) {
            delay = Array.isArray(delay) ? delay : [delay, delay];
            _a = delay.map(Number), this.openDelay = _a[0], this.closeDelay = _a[1];
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "open", {
        set: function (open) {
            this.toggle(open, open ? this.openDelay : this.closeDelay);
        },
        enumerable: true,
        configurable: true
    });
    TooltipDirective.prototype.onMouseClick = function ($event) {
        var _this = this;
        console.log("onMouseClick");
        if (this.behavior === 'click') {
            this.open = true;
            $event.preventDefault();
            setTimeout(function () {
                window.addEventListener('click', _this.onWindowsClick);
            });
        }
    };
    TooltipDirective.prototype.onWindowsClick = function () {
        console.log("onWindowsClick");
        if (this.behavior === 'click') {
            this.open = false;
            window.removeEventListener('click', this.onWindowsClick);
        }
    };
    TooltipDirective.prototype.onMouseOver = function () {
        if (this.behavior === 'hover') {
            this.open = true;
        }
    };
    TooltipDirective.prototype.onMouseOut = function () {
        if (this.behavior === 'hover') {
            this.open = false;
        }
    };
    TooltipDirective.prototype.onFocus = function () {
        if (this.behavior === 'focus') {
            this.open = true;
        }
    };
    TooltipDirective.prototype.onBlur = function () {
        if (this.behavior === 'focus') {
            this.open = false;
        }
    };
    TooltipDirective.prototype.position = function (async) {
        var _this = this;
        if (async === void 0) { async = true; }
        this.ngZone.runOutsideAngular(function () {
            if (async) {
                setTimeout(function () { return _this.tether.position(); });
            }
            else {
                _this.tether.position();
            }
        });
    };
    TooltipDirective.prototype.ngOnDestroy = function () {
        this.destroy();
    };
    TooltipDirective.prototype.toggle = function (open, delay) {
        var _this = this;
        if (this.toggleTimeout) {
            clearTimeout(this.toggleTimeout);
            this.toggleTimeout = null;
        }
        var toggleFn = (open ? this.create : this.destroy).bind(this);
        if (delay > 0) {
            this.toggleTimeout = setTimeout(function () {
                _this.toggleTimeout = null;
                toggleFn();
            }, delay);
        }
        else {
            toggleFn();
        }
    };
    TooltipDirective.prototype.setTether = function (create) {
        if (create === void 0) { create = false; }
        if (!this.tether && !create)
            return;
        var _a = placement(this._direction), attachment = _a.attachment, targetAttachment = _a.targetAttachment, offset = _a.offset;
        var options = {
            element: this.popover.element.nativeElement,
            target: this.element.nativeElement,
            attachment: attachment,
            targetAttachment: targetAttachment,
            offset: offset,
        };
        if (create) {
            this.tether = new Tether(options);
        }
        else {
            this.tether.setOptions(options);
        }
        this.setPopover();
    };
    TooltipDirective.prototype.setPopover = function () {
        if (!this.popover)
            return;
        var opposite = placement(this._direction).opposite;
    };
    TooltipDirective.prototype.create = function () {
        var _this = this;
        if (this.componentRef) {
            return;
        }
        var _a = this.getProjectableNodes(), nodes = _a.nodes, viewRef = _a.viewRef;
        this.viewRef = viewRef;
        this.componentRef = this.viewContainer.createComponent(this.popoverFactory, 0, this.injector, [nodes]);
        this.popover = this.componentRef.instance;
        this.popover.afterViewInit.take(1).subscribe(function () { return _this.position(false); });
        this.setTether(true);
        this.popover.changeDetector.markForCheck();
        this.toggled.emit(true);
    };
    TooltipDirective.prototype.getProjectableNodes = function () {
        if (this.tooltip instanceof TemplateRef) {
            var viewRef = this.viewContainer.createEmbeddedView(this.tooltip);
            return { nodes: viewRef.rootNodes, viewRef: viewRef };
        }
        else {
            return { nodes: [this.renderer.createText(null, this.tooltip)] };
        }
    };
    TooltipDirective.prototype.destroy = function () {
        if (!this.componentRef)
            return;
        this.tether.destroy();
        this.tether = null;
        if (this.viewRef) {
            this.viewContainer.remove(this.viewContainer.indexOf(this.viewRef));
            this.viewRef = null;
        }
        this.viewContainer.remove(this.viewContainer.indexOf(this.componentRef.hostView));
        this.componentRef.destroy();
        this.componentRef = null;
        this.popover = null;
        if (this.interactiveSubscription) {
            this.interactiveSubscription.unsubscribe();
        }
        this.toggled.emit(false);
    };
    TooltipDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[tooltip]',
                    host: {
                        "tabindex": "1"
                    }
                },] },
    ];
    /** @nocollapse */
    TooltipDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ViewContainerRef, },
        { type: Injector, },
        { type: NgZone, },
        { type: Renderer, },
        { type: ComponentFactoryResolver, },
    ]; };
    TooltipDirective.propDecorators = {
        'behavior': [{ type: Input },],
        'tooltip': [{ type: Input },],
        'direction': [{ type: Input },],
        'delay': [{ type: Input },],
        'open': [{ type: Input },],
        'toggled': [{ type: Output },],
        'onMouseClick': [{ type: HostListener, args: ['click', ['$event'],] },],
        'onMouseOver': [{ type: HostListener, args: ['mouseenter',] },],
        'onMouseOut': [{ type: HostListener, args: ['mouseleave',] },],
        'onFocus': [{ type: HostListener, args: ['focus',] },],
        'onBlur': [{ type: HostListener, args: ['blur',] },],
    };
    __decorate([
        bind
    ], TooltipDirective.prototype, "onWindowsClick", null);
    return TooltipDirective;
}());
export { TooltipDirective };
;
//# sourceMappingURL=tooltip.directive.js.map