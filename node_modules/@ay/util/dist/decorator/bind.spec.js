"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
var bind_1 = require("./bind");
require("should");
var assert = require("assert");
describe('autobind method decorator', function () {
    var A = (function () {
        function A() {
            this.value = 42;
        }
        A.prototype.getValue = function () {
            return this.value;
        };
        return A;
    }());
    __decorate([
        bind_1.bind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], A.prototype, "getValue", null);
    it('binds methods to an instance', function () {
        var a = new A();
        var getValue = a.getValue;
        getValue().should.equal(42);
    });
    it('binds method only once', function () {
        var a = new A();
        a.getValue.should.equal(a.getValue);
    });
    /** parse errors. Submitted issue to babel #1238
    it('binds methods with symbols as keys', function () {
      var symbol = Symbol('method');
      class A {
        constructor () {
          this.val = 42;
        }
        @autobind
        [symbol] () {
          return this.val;
        }
      }
      let a = new A();
      let getValue = a[symbol];
      assert(getValue() === 42);
    });
    */
    it('throws if applied on a method of more than zero arguments', function () {
        assert.throws(function () {
            var A = (function () {
                function A() {
                }
                Object.defineProperty(A.prototype, "value", {
                    get: function () {
                        return 1;
                    },
                    enumerable: true,
                    configurable: true
                });
                return A;
            }());
            __decorate([
                bind_1.bind,
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [])
            ], A.prototype, "value", null);
        }, /@autobind decorator can only be applied to methods/);
    });
    it('should not override binded instance method, while calling super method with the same name', function () {
        var B = (function (_super) {
            __extends(B, _super);
            function B() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            B.prototype.getValue = function () {
                return _super.prototype.getValue.call(this) + 8;
            };
            return B;
        }(A));
        __decorate([
            bind_1.bind,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], B.prototype, "getValue", null);
        var b = new B();
        var value = b.getValue();
        value = b.getValue();
        assert(value === 50);
    });
});
describe('autobind class decorator', function () {
    var symbol = Symbol('getValue');
    var A = (function () {
        function A() {
            this.value = 42;
        }
        A.prototype.getValue = function () {
            return this.value;
        };
        A.prototype[symbol] = function () {
            return this.value;
        };
        return A;
    }());
    A = __decorate([
        bind_1.bind,
        __metadata("design:paramtypes", [])
    ], A);
    it('binds methods to an instance', function () {
        var a = new A();
        var getValue = a.getValue;
        assert(getValue() === 42);
    });
    it('binds method only once', function () {
        var a = new A();
        assert(a.getValue === a.getValue);
    });
    it('ignores non method values', function () {
        assert.doesNotThrow(function () {
            var A = (function () {
                function A() {
                }
                Object.defineProperty(A.prototype, "value", {
                    get: function () {
                        return 1;
                    },
                    enumerable: true,
                    configurable: true
                });
                return A;
            }());
            A = __decorate([
                bind_1.bind
            ], A);
        });
    });
    it('does not override itself when accessed on the prototype', function () {
        A.prototype.getValue; // eslint-disable-line no-unused-expressions
        var a = new A();
        var getValue = a.getValue;
        assert(getValue() === 42);
    });
    describe('with Reflect', function () {
        describe('with Symbols', function () {
            it('binds methods with symbol keys', function () {
                var a = new A();
                var getValue = a[symbol];
                assert(getValue() === 42);
            });
        });
    });
    describe('without Reflect', function () {
        // remove Reflect pollyfill
        var _Reflect = Reflect;
        var A;
        before(function () {
            Reflect = undefined;
            var B = (function () {
                function B() {
                    this.value = 42;
                }
                B.prototype.getValue = function () {
                    return this.value;
                };
                B.prototype[symbol] = function () {
                    return this.value;
                };
                return B;
            }());
            B = __decorate([
                bind_1.bind,
                __metadata("design:paramtypes", [])
            ], B);
            A = B;
        });
        after(function () {
            Reflect = _Reflect;
        });
        it('falls back to Object.getOwnPropertyNames', function () {
            var a = new A();
            var getValue = a.getValue;
            assert(getValue() === 42);
        });
        describe('with Symbols', function () {
            it('falls back to Object.getOwnPropertySymbols', function () {
                var a = new A();
                var getValue = a[symbol];
                assert(getValue() === 42);
            });
        });
    });
    describe('without Symbols', function () {
        var _Symbol = Symbol;
        var _getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var A;
        before(function () {
            Symbol = undefined;
            Object.getOwnPropertySymbols = undefined;
            var B = (function () {
                function B() {
                    this.value = 42;
                }
                B.prototype.getValue = function () {
                    return this.value;
                };
                return B;
            }());
            B = __decorate([
                bind_1.bind,
                __metadata("design:paramtypes", [])
            ], B);
            A = B;
        });
        after(function () {
            Symbol = _Symbol;
            Object.getOwnPropertySymbols = _getOwnPropertySymbols;
        });
        it('does throws no error if Symbol is not supported', function () {
            var a = new A();
            var getValue = a.getValue;
            assert(getValue() === 42);
        });
    });
});
//# sourceMappingURL=bind.spec.js.map