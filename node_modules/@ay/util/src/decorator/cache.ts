import { isEqual } from "../isEqual"
import { defaults } from "../defaults";

type Cache = {
  params: any[],
  result?: any,
}


/**
 * 執行函式的結果會快取，當N豪秒內又執行此函數且參數一致時會直接返回上次計算的結果
 * @param {number} cacheFn 快取函數
 * @param {number} wait 快取時間(毫秒)(預設3000ms)
 * @param {boolean} deep 檢查參數時是否深度檢查(預設不深度檢查)
 */
export function cache(cacheFn: Function, wait: number, deep: boolean);
/**
 * 執行函式的結果會快取，當N豪秒內又執行此函數且參數一致時會直接返回上次計算的結果
 * @param {number} cacheFn 快取函數
 * @param {number} wait 快取時間(毫秒)(預設3000ms)
 * @param {boolean} deep 檢查參數時是否深度檢查(預設不檢查)
 */
export function cache(cacheFn: Function, wait: number);
/**
 * 執行函式的結果會快取，當N豪秒內又執行此函數且參數一致時會直接返回上次計算的結果
 * @param {number} cacheFn 快取函數
 * @param {number} wait 快取時間(毫秒)(預設3000ms)
 * @param {boolean} deep 檢查參數時是否深度檢查(預設不檢查)
 */
export function cache(cacheFn: Function);
/**
 * [Function Decorator]
 * 執行函式的結果會快取，當N豪秒內又執行此函數且參數一致時會直接返回上次計算的結果
 * @param {number} wait 快取時間(毫秒)(預設3000ms)
 * @param {boolean} deep 檢查參數時是否深度檢查(預設不檢查)
 */
export function cache(wait: number, deep: boolean);
/**
 * [Function Decorator]
 * 執行函式的結果會快取，當N豪秒內又執行此函數且參數一致時會直接返回上次計算的結果
 * @param {number} wait 快取時間(毫秒)(預設3000ms)
 * @param {boolean} deep 檢查參數時是否深度檢查(預設不檢查)
 */
export function cache(wait: number);
/**
 * [Function Decorator]
 * 執行函式的結果會快取，當N豪秒內又執行此函數且參數一致時會直接返回上次計算的結果
 * @param {number} wait 快取時間(毫秒)(預設3000ms)
 * @param {boolean} deep 檢查參數時是否深度檢查(預設不檢查)
 */
export function cache();
export function cache(...args) {
  let func;
  let wait;
  let deep;
  let caches;
  let cacheFunc = function (...params) {
    let cache = caches.find(cache => isEqual(cache.params, params, deep));
    if (cache) return cache.result;
    let result = func.apply(this, [...params]);
    cache = { params, result };
    caches.push(cache);
    setTimeout(() => {
      let idx = caches.indexOf(cache);
      caches.splice(idx, 1);
    }, wait);
    return result;
  }
  if (args[0] instanceof Function) {
    func = args[0];
    wait = defaults(args[1], 3000);
    deep = defaults(args[2], false);
    if (_caches[func.name] === undefined) _caches[func.name] = [];
    caches = _caches[func.name];
    return cacheFunc;

  } else {
    wait = defaults(args[0], 3000);
    deep = defaults(args[1], false);

    return function decorator(target, key, descriptor) {
      func = descriptor.value;
      if (_caches[key] === undefined) _caches[key] = [];
      caches = _caches[key];
      descriptor.value = cacheFunc;
      return descriptor;
    }
  }
}

let _caches: { [key: string]: Cache[] } = {};
