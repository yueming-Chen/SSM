import * as mocha from "mocha";
import * as should from "should";
import { bind } from "./bind";
require("should");
import * as assert from "assert";

declare var Reflect;
describe('autobind method decorator', function () {

  class A {
    public value: number;
    constructor() {
      this.value = 42;
    }

    @bind
    getValue() {
      return this.value;
    }
  }

  it('binds methods to an instance', function () {
    let a = new A();
    let getValue = a.getValue;
    getValue().should.equal(42);
  });

  it('binds method only once', function () {
    let a = new A();
    a.getValue.should.equal(a.getValue);
  });

  /** parse errors. Submitted issue to babel #1238
  it('binds methods with symbols as keys', function () {
    var symbol = Symbol('method');
    class A {
      constructor () {
        this.val = 42;
      }
      @autobind
      [symbol] () {
        return this.val;
      }
    }
    let a = new A();
    let getValue = a[symbol];
    assert(getValue() === 42);
  });
  */

  it('throws if applied on a method of more than zero arguments', function () {
    assert.throws(() => {
      class A { // eslint-disable-line no-unused-vars
        @bind
        get value() {
          return 1;
        }
      }
    }, /@autobind decorator can only be applied to methods/);
  });


  it('should not override binded instance method, while calling super method with the same name', function () { // eslint-disable-line max-len
    class B extends A {

      @bind
      getValue() {
        return super.getValue() + 8;
      }
    }

    let b = new B();
    let value = b.getValue();
    value = b.getValue();

    assert(value === 50);
  });
});

describe('autobind class decorator', function () {

  let symbol = Symbol('getValue');

  @bind
  class A {
    public value: number;
    constructor() {
      this.value = 42;
    }

    getValue() {
      return this.value;
    }

    [symbol]() {
      return this.value;
    }
  }

  it('binds methods to an instance', function () {
    let a = new A();
    let getValue = a.getValue;
    assert(getValue() === 42);
  });

  it('binds method only once', function () {
    let a = new A();
    assert(a.getValue === a.getValue);
  });

  it('ignores non method values', function () {
    assert.doesNotThrow(() => {
      @bind
      class A { // eslint-disable-line no-unused-vars
        get value() {
          return 1;
        }
      }
    });
  });

  it('does not override itself when accessed on the prototype', function () {
    A.prototype.getValue; // eslint-disable-line no-unused-expressions

    let a = new A();
    let getValue = a.getValue;
    assert(getValue() === 42);
  });

  describe('with Reflect', function () {
    describe('with Symbols', function () {
      it('binds methods with symbol keys', function () {
        let a = new A();
        let getValue = a[symbol];
        assert(getValue() === 42);
      });
    });
  });


  describe('without Reflect', function () {
    // remove Reflect pollyfill
    let _Reflect = Reflect;
    let A;

    before(function () {
      Reflect = undefined;

      @bind
      class B {
        public value: number;
        constructor() {
          this.value = 42;
        }
        getValue() {
          return this.value;
        }
        [symbol]() {
          return this.value;
        }
      }
      A = B;
    });

    after(function () {
      Reflect = _Reflect;
    });

    it('falls back to Object.getOwnPropertyNames', function () {
      let a = new A();
      let getValue = a.getValue;
      assert(getValue() === 42);
    });

    describe('with Symbols', function () {
      it('falls back to Object.getOwnPropertySymbols', function () {
        let a = new A();
        let getValue = a[symbol];
        assert(getValue() === 42);
      });
    });
  });

  describe('without Symbols', function () {
    let _Symbol = Symbol;
    let _getOwnPropertySymbols = Object.getOwnPropertySymbols;
    let A;

    before(function () {
      Symbol = undefined;
      Object.getOwnPropertySymbols = undefined;

      @bind
      class B {
        public value;
        constructor() {
          this.value = 42;
        }
        getValue() {
          return this.value;
        }
      }
      A = B;
    });

    after(function () {
      Symbol = _Symbol;
      Object.getOwnPropertySymbols = _getOwnPropertySymbols;
    });

    it('does throws no error if Symbol is not supported', function () {
      let a = new A();
      let getValue = a.getValue;
      assert(getValue() === 42);
    });
  });
});